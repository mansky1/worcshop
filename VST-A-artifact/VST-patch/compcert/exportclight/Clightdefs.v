(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation, either version 2 of the License, or  *)
(*  (at your option) any later version.  This file is also distributed *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** All imports and definitions used by .v Clight files generated by clightgen *)

From Coq Require Import String List ZArith.
From compcert Require Import Integers Floats Maps Errors AST Ctypes Cop Clight.

Definition tvoid := Tvoid.
Definition tschar := Tint I8 Signed noattr.
Definition tuchar := Tint I8 Unsigned noattr.
Definition tshort := Tint I16 Signed noattr.
Definition tushort := Tint I16 Unsigned noattr.
Definition tint := Tint I32 Signed noattr.
Definition tuint := Tint I32 Unsigned noattr.
Definition tbool := Tint IBool Unsigned noattr.
Definition tlong := Tlong Signed noattr.
Definition tulong := Tlong Unsigned noattr.
Definition tfloat := Tfloat F32 noattr.
Definition tdouble := Tfloat F64 noattr.
Definition tptr (t: type) := Tpointer t noattr.
Definition tarray (t: type) (sz: Z) := Tarray t sz noattr.

Definition volatile_attr := {| attr_volatile := true; attr_alignas := None |}.

Definition tattr (a: attr) (ty: type) :=
  match ty with
  | Tvoid => Tvoid
  | Tint sz si _ => Tint sz si a
  | Tlong si _ => Tlong si a
  | Tfloat sz _ => Tfloat sz a
  | Tpointer elt _ => Tpointer elt a
  | Tarray elt sz _ => Tarray elt sz a
  | Tfunction args res cc => Tfunction args res cc
  | Tstruct id _ => Tstruct id a
  | Tunion id  _ => Tunion id a
  end.

Definition tvolatile (ty: type) := tattr volatile_attr ty.

Definition talignas (n: N) (ty: type) :=
  tattr {| attr_volatile := false; attr_alignas := Some n |} ty.

Definition tvolatile_alignas (n: N) (ty: type) :=
  tattr {| attr_volatile := true; attr_alignas := Some n |} ty.

Definition wf_composites (types: list composite_definition) : Prop :=
  match build_composite_env types with OK _ => True | Error _ => False end.

Definition build_composite_env' (types: list composite_definition)
                                (WF: wf_composites types)
                             : { ce | build_composite_env types  = OK ce }.
Proof.
  revert WF. unfold wf_composites. case (build_composite_env types); intros.
- exists c; reflexivity.
- contradiction.
Defined.

Definition mkprogram (types: list composite_definition)
                     (defs: list (ident * globdef fundef type))
                     (public: list ident)
                     (main: ident)
                     (WF: wf_composites types) : Clight.program :=
  let (ce, EQ) := build_composite_env' types WF in
  {| prog_defs := defs;
     prog_public := public;
     prog_main := main;
     prog_types := types;
     prog_comp_env := ce;
     prog_comp_env_eq := EQ |}.

Definition bool2posdigit (b: bool) : positive -> positive :=
 if b then xI else xO.

Definition string2ident_base : positive := 512.
(* This function converts an Ascii string representing a C identifier
  into a positive number >= string2ident_base.   Characters that more
  frequently appear in C identifiers have shorter encodings. *)
Fixpoint string2ident (s: string) : ident :=
 match s with
 | EmptyString => 512%positive
 | String (Ascii.Ascii b0 b1 b2 b3 b4 b5 b6 b7) r =>
    let r' := string2ident r in
    if (b7 ||
      negb b6 && negb b5 ||
      negb b6 && b5 && negb b4 ||
      b6 && negb b5 && b4 && b3 && negb b2 ||
      b6 && b5 && negb (b4 || b3 || b2 || b1 || b0) ||
      b6 && b5 && b3 && b2)%bool
    then (*these characters should not appear in idents *)
           xI (xI (xI (bool2posdigit b6 (bool2posdigit b5
              (bool2posdigit b4 (bool2posdigit b3
               (bool2posdigit b2 (bool2posdigit b1 
                (bool2posdigit b0 r')))))))))
    else if b6  
    then (* letters, etc. *)
        if b5
        then (* lowercase letters, etc. *)
           xO (bool2posdigit b4 (bool2posdigit b3
               (bool2posdigit b2 (bool2posdigit b1 
                (bool2posdigit b0 r')))))
        else (* uppercase letters, etc. *)
           if (b4 && b3 && b2 && b1 && b0)%bool
           then (* underscore *)
                  xO (xI (xI (xI r')))
           else
           xI (xO (bool2posdigit b4 (bool2posdigit b3
               (bool2posdigit b2 (bool2posdigit b1 
                (bool2posdigit b0 r'))))))
     else (* numbers, etc. *)
          xI (xI (xO (bool2posdigit b4 (bool2posdigit b3
               (bool2posdigit b2 (bool2posdigit b1 
                (bool2posdigit b0 r')))))))
 end.

Ltac string2ident s :=
  let s' := constr:(string2ident s) in
  let s' := eval compute in s' in
  exact s'.
